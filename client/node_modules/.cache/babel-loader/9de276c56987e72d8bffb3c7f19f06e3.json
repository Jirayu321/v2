{"ast":null,"code":"import { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nconst handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\n\nexport default class Mapbox {\n  constructor(MapClass, props, container) {\n    // mapboxgl.Map instance. Not using type here because we are accessing\n    // private members and methods\n    this._map = null; // Internal states\n\n    this._internalUpdate = false;\n    this._inRender = false;\n    this._hoveredFeatures = null;\n    this._deferredEvents = {\n      move: false,\n      zoom: false,\n      pitch: false,\n      rotate: false\n    };\n\n    this._onEvent = e => {\n      // @ts-ignore\n      const cb = this.props[otherEvents[e.type]];\n\n      if (cb) {\n        cb(e);\n      }\n    };\n\n    this._onPointerEvent = e => {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        this._updateHover(e);\n      } // @ts-ignore\n\n\n      const cb = this.props[pointerEvents[e.type]];\n\n      if (cb) {\n        if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          const features = this._hoveredFeatures || this._map.queryRenderedFeatures(e.point, {\n            layers: this.props.interactiveLayerIds\n          });\n\n          e.features = features;\n        }\n\n        cb(e);\n        delete e.features;\n      }\n    };\n\n    this._onCameraEvent = e => {\n      if (!this._internalUpdate) {\n        // @ts-ignore\n        const cb = this.props[cameraEvents[e.type]];\n\n        if (cb) {\n          cb(e);\n        }\n      }\n\n      if (e.type in this._deferredEvents) {\n        this._deferredEvents[e.type] = false;\n      }\n    };\n\n    this._MapClass = MapClass;\n    this.props = props;\n\n    this._initialize(container);\n  }\n\n  get map() {\n    return this._map;\n  }\n\n  get transform() {\n    return this._renderTransform;\n  }\n\n  setProps(props) {\n    const oldProps = this.props;\n    this.props = props;\n\n    const settingsChanged = this._updateSettings(props, oldProps);\n\n    if (settingsChanged) {\n      this._createShadowTransform(this._map);\n    }\n\n    const sizeChanged = this._updateSize(props);\n\n    const viewStateChanged = this._updateViewState(props, true);\n\n    this._updateStyle(props, oldProps);\n\n    this._updateStyleComponents(props, oldProps);\n\n    this._updateHandlers(props, oldProps); // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n\n\n    if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n      this.redraw();\n    }\n  }\n\n  static reuse(props, container) {\n    const that = Mapbox.savedMaps.pop();\n\n    if (!that) {\n      return null;\n    }\n\n    const map = that.map; // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step1: reparenting child nodes from old container to new container\n\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    } // Step2: replace the internal container with new container from the react component\n    // @ts-ignore\n\n\n    map._container = container; // Step 3: apply new props\n\n    that.setProps({ ...props,\n      styleDiffing: false\n    });\n    map.resize();\n    const {\n      initialViewState\n    } = props;\n\n    if (initialViewState) {\n      if (initialViewState.bounds) {\n        map.fitBounds(initialViewState.bounds, { ...initialViewState.fitBoundsOptions,\n          duration: 0\n        });\n      } else {\n        that._updateViewState(initialViewState, false);\n      }\n    } // Simulate load event\n\n\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('styledata', () => map.fire('load'));\n    }\n\n    return that;\n  }\n  /* eslint-disable complexity,max-statements */\n\n\n  _initialize(container) {\n    const {\n      props\n    } = this;\n    const mapOptions = { ...props,\n      ...props.initialViewState,\n      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n      container,\n      style: normalizeStyle(props.mapStyle)\n    };\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext; // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n\n    const map = new this._MapClass(mapOptions); // Props that are not part of constructor options\n\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n\n    this._createShadowTransform(map); // Hack\n    // Insert code into map's render cycle\n\n\n    const renderMap = map._render;\n\n    map._render = arg => {\n      this._inRender = true;\n      renderMap.call(map, arg);\n      this._inRender = false;\n    };\n\n    const runRenderTaskQueue = map._renderTaskQueue.run;\n\n    map._renderTaskQueue.run = arg => {\n      runRenderTaskQueue.call(map._renderTaskQueue, arg);\n\n      this._onBeforeRepaint();\n    };\n\n    map.on('render', () => this._onAfterRepaint()); // Insert code into map's event pipeline\n\n    const fireEvent = map.fire;\n    map.fire = this._fireEvent.bind(this, fireEvent); // add listeners\n\n    map.on('resize', () => {\n      this._renderTransform.resize(map.transform.width, map.transform.height);\n    });\n    map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n    map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n\n\n  recycle() {\n    // Clean up unnecessary elements before storing for reuse.\n    const container = this.map.getContainer();\n    const children = container.querySelector('[mapboxgl-children]');\n    children === null || children === void 0 ? void 0 : children.remove();\n    Mapbox.savedMaps.push(this);\n  }\n\n  destroy() {\n    this._map.remove();\n  } // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n\n\n  redraw() {\n    const map = this._map; // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n\n    if (!this._inRender && map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n\n        map._frame = null;\n      } // the order is important - render() may schedule another update\n\n\n      map._render();\n    }\n  }\n\n  _createShadowTransform(map) {\n    const renderTransform = cloneTransform(map.transform);\n    map.painter.transform = renderTransform;\n    this._renderTransform = renderTransform;\n  }\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n\n\n  _updateSize(nextProps) {\n    // Check if size is controlled\n    const {\n      viewState\n    } = nextProps;\n\n    if (viewState) {\n      const map = this._map;\n\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n\n    return false;\n  } // Adapted from map.jumpTo\n\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateViewState(nextProps, triggerEvents) {\n    if (this._internalUpdate) {\n      return false;\n    }\n\n    const map = this._map;\n    const tr = this._renderTransform; // Take a snapshot of the transform before mutation\n\n    const {\n      zoom,\n      pitch,\n      bearing\n    } = tr;\n    const isMoving = map.isMoving();\n\n    if (isMoving) {\n      // All movement of the camera is done relative to the sea level\n      tr.cameraElevationReference = 'sea';\n    }\n\n    const changed = applyViewStateToTransform(tr, { ...transformToViewState(map.transform),\n      ...nextProps\n    });\n\n    if (isMoving) {\n      // Reset camera reference\n      tr.cameraElevationReference = 'ground';\n    }\n\n    if (changed && triggerEvents) {\n      const deferredEvents = this._deferredEvents; // Delay DOM control updates to the next render cycle\n\n      deferredEvents.move = true;\n      deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n      deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n      deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n    } // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n\n\n    if (!isMoving) {\n      applyViewStateToTransform(map.transform, nextProps);\n    }\n\n    return changed;\n  }\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateSettings(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n      }\n    }\n\n    return changed;\n  }\n  /* Update map style to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if style is changed\n   */\n\n\n  _updateStyle(nextProps, currProps) {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor;\n    }\n\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const options = {\n        diff: nextProps.styleDiffing\n      };\n\n      if ('localIdeographFontFamily' in nextProps) {\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n\n      this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n\n      return true;\n    }\n\n    return false;\n  }\n  /* Update fog, light and terrain to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateStyleComponents(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    if (map.style.loaded()) {\n      if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n        changed = true;\n        map.setLight(nextProps.light);\n      }\n\n      if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n        changed = true;\n        map.setFog(nextProps.fog);\n      }\n\n      if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n        if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n          changed = true;\n          map.setTerrain(nextProps.terrain);\n        }\n      }\n    }\n\n    return changed;\n  }\n  /* Update interaction handlers to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateHandlers(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    for (const propName of handlerNames) {\n      const newValue = nextProps[propName];\n\n      if (!deepEqual(newValue, currProps[propName])) {\n        changed = true;\n\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n\n    return changed;\n  }\n\n  _updateHover(e) {\n    var _a;\n\n    const {\n      props\n    } = this;\n    const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n      let features;\n\n      if (eventType === 'mousemove') {\n        try {\n          features = this._map.queryRenderedFeatures(e.point, {\n            layers: props.interactiveLayerIds\n          });\n        } catch (_b) {\n          features = [];\n        }\n      } else {\n        features = [];\n      }\n\n      const isHovering = features.length > 0;\n\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n\n        this._onPointerEvent(e);\n      }\n\n      this._hoveredFeatures = features;\n\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n\n        this._onPointerEvent(e);\n      }\n\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n\n  _fireEvent(baseFire, event, properties) {\n    const map = this._map;\n    const tr = map.transform;\n    const eventType = typeof event === 'string' ? event : event.type;\n\n    if (eventType === 'move') {\n      this._updateViewState(this.props, false);\n    }\n\n    if (eventType in cameraEvents) {\n      if (typeof event === 'object') {\n        event.viewState = transformToViewState(tr);\n      }\n\n      if (this._map.isMoving()) {\n        // Replace map.transform with ours during the callbacks\n        map.transform = this._renderTransform;\n        baseFire.call(map, event, properties);\n        map.transform = tr;\n        return map;\n      }\n    }\n\n    baseFire.call(map, event, properties);\n    return map;\n  } // All camera manipulations are complete, ready to repaint\n\n\n  _onBeforeRepaint() {\n    const map = this._map; // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n\n    this._internalUpdate = true;\n\n    for (const eventType in this._deferredEvents) {\n      if (this._deferredEvents[eventType]) {\n        map.fire(eventType);\n      }\n    }\n\n    this._internalUpdate = false;\n    const tr = this._map.transform; // Make sure camera matches the current props\n\n    this._map.transform = this._renderTransform;\n\n    this._onAfterRepaint = () => {\n      // Restores camera state before render/load events are fired\n      this._map.transform = tr;\n    };\n  }\n\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\n\nfunction getAccessTokenFromEnv() {\n  let accessToken = null;\n  /* global location, process */\n\n  if (typeof location !== 'undefined') {\n    const match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  } // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n\n\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch (_a) {// ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch (_b) {// ignore\n  }\n\n  return accessToken;\n}","map":{"version":3,"sources":["../../../src/mapbox/mapbox.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nconst pointerEvents = {\n    mousedown: 'onMouseDown',\n    mouseup: 'onMouseUp',\n    mouseover: 'onMouseOver',\n    mousemove: 'onMouseMove',\n    click: 'onClick',\n    dblclick: 'onDblClick',\n    mouseenter: 'onMouseEnter',\n    mouseleave: 'onMouseLeave',\n    mouseout: 'onMouseOut',\n    contextmenu: 'onContextMenu',\n    touchstart: 'onTouchStart',\n    touchend: 'onTouchEnd',\n    touchmove: 'onTouchMove',\n    touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n    movestart: 'onMoveStart',\n    move: 'onMove',\n    moveend: 'onMoveEnd',\n    dragstart: 'onDragStart',\n    drag: 'onDrag',\n    dragend: 'onDragEnd',\n    zoomstart: 'onZoomStart',\n    zoom: 'onZoom',\n    zoomend: 'onZoomEnd',\n    rotatestart: 'onRotateStart',\n    rotate: 'onRotate',\n    rotateend: 'onRotateEnd',\n    pitchstart: 'onPitchStart',\n    pitch: 'onPitch',\n    pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n    wheel: 'onWheel',\n    boxzoomstart: 'onBoxZoomStart',\n    boxzoomend: 'onBoxZoomEnd',\n    boxzoomcancel: 'onBoxZoomCancel',\n    resize: 'onResize',\n    load: 'onLoad',\n    render: 'onRender',\n    idle: 'onIdle',\n    remove: 'onRemove',\n    data: 'onData',\n    styledata: 'onStyleData',\n    sourcedata: 'onSourceData',\n    error: 'onError'\n};\nconst settingNames = [\n    'minZoom',\n    'maxZoom',\n    'minPitch',\n    'maxPitch',\n    'maxBounds',\n    'projection',\n    'renderWorldCopies'\n];\nconst handlerNames = [\n    'scrollZoom',\n    'boxZoom',\n    'dragRotate',\n    'dragPan',\n    'keyboard',\n    'doubleClickZoom',\n    'touchZoomRotate',\n    'touchPitch'\n];\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox {\n    constructor(MapClass, props, container) {\n        // mapboxgl.Map instance. Not using type here because we are accessing\n        // private members and methods\n        this._map = null;\n        // Internal states\n        this._internalUpdate = false;\n        this._inRender = false;\n        this._hoveredFeatures = null;\n        this._deferredEvents = {\n            move: false,\n            zoom: false,\n            pitch: false,\n            rotate: false\n        };\n        this._onEvent = (e) => {\n            // @ts-ignore\n            const cb = this.props[otherEvents[e.type]];\n            if (cb) {\n                cb(e);\n            }\n        };\n        this._onPointerEvent = (e) => {\n            if (e.type === 'mousemove' || e.type === 'mouseout') {\n                this._updateHover(e);\n            }\n            // @ts-ignore\n            const cb = this.props[pointerEvents[e.type]];\n            if (cb) {\n                if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n                    const features = this._hoveredFeatures ||\n                        this._map.queryRenderedFeatures(e.point, {\n                            layers: this.props.interactiveLayerIds\n                        });\n                    e.features = features;\n                }\n                cb(e);\n                delete e.features;\n            }\n        };\n        this._onCameraEvent = (e) => {\n            if (!this._internalUpdate) {\n                // @ts-ignore\n                const cb = this.props[cameraEvents[e.type]];\n                if (cb) {\n                    cb(e);\n                }\n            }\n            if (e.type in this._deferredEvents) {\n                this._deferredEvents[e.type] = false;\n            }\n        };\n        this._MapClass = MapClass;\n        this.props = props;\n        this._initialize(container);\n    }\n    get map() {\n        return this._map;\n    }\n    get transform() {\n        return this._renderTransform;\n    }\n    setProps(props) {\n        const oldProps = this.props;\n        this.props = props;\n        const settingsChanged = this._updateSettings(props, oldProps);\n        if (settingsChanged) {\n            this._createShadowTransform(this._map);\n        }\n        const sizeChanged = this._updateSize(props);\n        const viewStateChanged = this._updateViewState(props, true);\n        this._updateStyle(props, oldProps);\n        this._updateStyleComponents(props, oldProps);\n        this._updateHandlers(props, oldProps);\n        // If 1) view state has changed to match props and\n        //    2) the props change is not triggered by map events,\n        // it's driven by an external state change. Redraw immediately\n        if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n            this.redraw();\n        }\n    }\n    static reuse(props, container) {\n        const that = Mapbox.savedMaps.pop();\n        if (!that) {\n            return null;\n        }\n        const map = that.map;\n        // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n        // intoto the new container from the props.\n        // Step1: reparenting child nodes from old container to new container\n        const oldContainer = map.getContainer();\n        container.className = oldContainer.className;\n        while (oldContainer.childNodes.length > 0) {\n            container.appendChild(oldContainer.childNodes[0]);\n        }\n        // Step2: replace the internal container with new container from the react component\n        // @ts-ignore\n        map._container = container;\n        // Step 3: apply new props\n        that.setProps({ ...props, styleDiffing: false });\n        map.resize();\n        const { initialViewState } = props;\n        if (initialViewState) {\n            if (initialViewState.bounds) {\n                map.fitBounds(initialViewState.bounds, { ...initialViewState.fitBoundsOptions, duration: 0 });\n            }\n            else {\n                that._updateViewState(initialViewState, false);\n            }\n        }\n        // Simulate load event\n        if (map.isStyleLoaded()) {\n            map.fire('load');\n        }\n        else {\n            map.once('styledata', () => map.fire('load'));\n        }\n        return that;\n    }\n    /* eslint-disable complexity,max-statements */\n    _initialize(container) {\n        const { props } = this;\n        const mapOptions = {\n            ...props,\n            ...props.initialViewState,\n            accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n            container,\n            style: normalizeStyle(props.mapStyle)\n        };\n        const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n        Object.assign(mapOptions, {\n            center: [viewState.longitude || 0, viewState.latitude || 0],\n            zoom: viewState.zoom || 0,\n            pitch: viewState.pitch || 0,\n            bearing: viewState.bearing || 0\n        });\n        if (props.gl) {\n            // eslint-disable-next-line\n            const getContext = HTMLCanvasElement.prototype.getContext;\n            // Hijack canvas.getContext to return our own WebGLContext\n            // This will be called inside the mapboxgl.Map constructor\n            // @ts-expect-error\n            HTMLCanvasElement.prototype.getContext = () => {\n                // Unhijack immediately\n                HTMLCanvasElement.prototype.getContext = getContext;\n                return props.gl;\n            };\n        }\n        const map = new this._MapClass(mapOptions);\n        // Props that are not part of constructor options\n        if (viewState.padding) {\n            map.setPadding(viewState.padding);\n        }\n        if (props.cursor) {\n            map.getCanvas().style.cursor = props.cursor;\n        }\n        this._createShadowTransform(map);\n        // Hack\n        // Insert code into map's render cycle\n        const renderMap = map._render;\n        map._render = (arg) => {\n            this._inRender = true;\n            renderMap.call(map, arg);\n            this._inRender = false;\n        };\n        const runRenderTaskQueue = map._renderTaskQueue.run;\n        map._renderTaskQueue.run = (arg) => {\n            runRenderTaskQueue.call(map._renderTaskQueue, arg);\n            this._onBeforeRepaint();\n        };\n        map.on('render', () => this._onAfterRepaint());\n        // Insert code into map's event pipeline\n        const fireEvent = map.fire;\n        map.fire = this._fireEvent.bind(this, fireEvent);\n        // add listeners\n        map.on('resize', () => {\n            this._renderTransform.resize(map.transform.width, map.transform.height);\n        });\n        map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n        map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n        for (const eventName in pointerEvents) {\n            map.on(eventName, this._onPointerEvent);\n        }\n        for (const eventName in cameraEvents) {\n            map.on(eventName, this._onCameraEvent);\n        }\n        for (const eventName in otherEvents) {\n            map.on(eventName, this._onEvent);\n        }\n        this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n    recycle() {\n        // Clean up unnecessary elements before storing for reuse.\n        const container = this.map.getContainer();\n        const children = container.querySelector('[mapboxgl-children]');\n        children === null || children === void 0 ? void 0 : children.remove();\n        Mapbox.savedMaps.push(this);\n    }\n    destroy() {\n        this._map.remove();\n    }\n    // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n    redraw() {\n        const map = this._map;\n        // map._render will throw error if style does not exist\n        // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n        //   /src/ui/map.js#L1834\n        if (!this._inRender && map.style) {\n            // cancel the scheduled update\n            if (map._frame) {\n                map._frame.cancel();\n                map._frame = null;\n            }\n            // the order is important - render() may schedule another update\n            map._render();\n        }\n    }\n    _createShadowTransform(map) {\n        const renderTransform = cloneTransform(map.transform);\n        map.painter.transform = renderTransform;\n        this._renderTransform = renderTransform;\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n    _updateSize(nextProps) {\n        // Check if size is controlled\n        const { viewState } = nextProps;\n        if (viewState) {\n            const map = this._map;\n            if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n                map.resize();\n                return true;\n            }\n        }\n        return false;\n    }\n    // Adapted from map.jumpTo\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n    _updateViewState(nextProps, triggerEvents) {\n        if (this._internalUpdate) {\n            return false;\n        }\n        const map = this._map;\n        const tr = this._renderTransform;\n        // Take a snapshot of the transform before mutation\n        const { zoom, pitch, bearing } = tr;\n        const isMoving = map.isMoving();\n        if (isMoving) {\n            // All movement of the camera is done relative to the sea level\n            tr.cameraElevationReference = 'sea';\n        }\n        const changed = applyViewStateToTransform(tr, {\n            ...transformToViewState(map.transform),\n            ...nextProps\n        });\n        if (isMoving) {\n            // Reset camera reference\n            tr.cameraElevationReference = 'ground';\n        }\n        if (changed && triggerEvents) {\n            const deferredEvents = this._deferredEvents;\n            // Delay DOM control updates to the next render cycle\n            deferredEvents.move = true;\n            deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n            deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n            deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n        }\n        // Avoid manipulating the real transform when interaction/animation is ongoing\n        // as it would interfere with Mapbox's handlers\n        if (!isMoving) {\n            applyViewStateToTransform(map.transform, nextProps);\n        }\n        return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateSettings(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of settingNames) {\n            if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n                changed = true;\n                map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n            }\n        }\n        return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n    _updateStyle(nextProps, currProps) {\n        if (nextProps.cursor !== currProps.cursor) {\n            this._map.getCanvas().style.cursor = nextProps.cursor;\n        }\n        if (nextProps.mapStyle !== currProps.mapStyle) {\n            const options = {\n                diff: nextProps.styleDiffing\n            };\n            if ('localIdeographFontFamily' in nextProps) {\n                options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n            }\n            this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n            return true;\n        }\n        return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateStyleComponents(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        if (map.style.loaded()) {\n            if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n                changed = true;\n                map.setLight(nextProps.light);\n            }\n            if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n                changed = true;\n                map.setFog(nextProps.fog);\n            }\n            if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n                if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n                    changed = true;\n                    map.setTerrain(nextProps.terrain);\n                }\n            }\n        }\n        return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateHandlers(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of handlerNames) {\n            const newValue = nextProps[propName];\n            if (!deepEqual(newValue, currProps[propName])) {\n                changed = true;\n                if (newValue) {\n                    map[propName].enable(newValue);\n                }\n                else {\n                    map[propName].disable();\n                }\n            }\n        }\n        return changed;\n    }\n    _updateHover(e) {\n        var _a;\n        const { props } = this;\n        const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n        if (shouldTrackHoveredFeatures) {\n            const eventType = e.type;\n            const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n            let features;\n            if (eventType === 'mousemove') {\n                try {\n                    features = this._map.queryRenderedFeatures(e.point, {\n                        layers: props.interactiveLayerIds\n                    });\n                }\n                catch (_b) {\n                    features = [];\n                }\n            }\n            else {\n                features = [];\n            }\n            const isHovering = features.length > 0;\n            if (!isHovering && wasHovering) {\n                e.type = 'mouseleave';\n                this._onPointerEvent(e);\n            }\n            this._hoveredFeatures = features;\n            if (isHovering && !wasHovering) {\n                e.type = 'mouseenter';\n                this._onPointerEvent(e);\n            }\n            e.type = eventType;\n        }\n        else {\n            this._hoveredFeatures = null;\n        }\n    }\n    _fireEvent(baseFire, event, properties) {\n        const map = this._map;\n        const tr = map.transform;\n        const eventType = typeof event === 'string' ? event : event.type;\n        if (eventType === 'move') {\n            this._updateViewState(this.props, false);\n        }\n        if (eventType in cameraEvents) {\n            if (typeof event === 'object') {\n                event.viewState = transformToViewState(tr);\n            }\n            if (this._map.isMoving()) {\n                // Replace map.transform with ours during the callbacks\n                map.transform = this._renderTransform;\n                baseFire.call(map, event, properties);\n                map.transform = tr;\n                return map;\n            }\n        }\n        baseFire.call(map, event, properties);\n        return map;\n    }\n    // All camera manipulations are complete, ready to repaint\n    _onBeforeRepaint() {\n        const map = this._map;\n        // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n        this._internalUpdate = true;\n        for (const eventType in this._deferredEvents) {\n            if (this._deferredEvents[eventType]) {\n                map.fire(eventType);\n            }\n        }\n        this._internalUpdate = false;\n        const tr = this._map.transform;\n        // Make sure camera matches the current props\n        this._map.transform = this._renderTransform;\n        this._onAfterRepaint = () => {\n            // Restores camera state before render/load events are fired\n            this._map.transform = tr;\n        };\n    }\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv() {\n    let accessToken = null;\n    /* global location, process */\n    if (typeof location !== 'undefined') {\n        const match = /access_token=([^&\\/]*)/.exec(location.search);\n        accessToken = match && match[1];\n    }\n    // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n    try {\n        accessToken = accessToken || process.env.MapboxAccessToken;\n    }\n    catch (_a) {\n        // ignore\n    }\n    try {\n        accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n    }\n    catch (_b) {\n        // ignore\n    }\n    return accessToken;\n}\n//# sourceMappingURL=mapbox.js.map"]},"metadata":{},"sourceType":"module"}