{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/jirayuyungmeesuk/Desktop/ v2/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"/Users/jirayuyungmeesuk/Desktop/ v2/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/Users/jirayuyungmeesuk/Desktop/ v2/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jirayuyungmeesuk/Desktop/ v2/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nvar pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nvar cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nvar otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nvar settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nvar handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\n\nvar Mapbox = /*#__PURE__*/function () {\n  function Mapbox(MapClass, props, container) {\n    var _this = this;\n\n    _classCallCheck(this, Mapbox);\n\n    // mapboxgl.Map instance. Not using type here because we are accessing\n    // private members and methods\n    this._map = null; // Internal states\n\n    this._internalUpdate = false;\n    this._inRender = false;\n    this._hoveredFeatures = null;\n    this._deferredEvents = {\n      move: false,\n      zoom: false,\n      pitch: false,\n      rotate: false\n    };\n\n    this._onEvent = function (e) {\n      // @ts-ignore\n      var cb = _this.props[otherEvents[e.type]];\n\n      if (cb) {\n        cb(e);\n      }\n    };\n\n    this._onPointerEvent = function (e) {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        _this._updateHover(e);\n      } // @ts-ignore\n\n\n      var cb = _this.props[pointerEvents[e.type]];\n\n      if (cb) {\n        if (_this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          var features = _this._hoveredFeatures || _this._map.queryRenderedFeatures(e.point, {\n            layers: _this.props.interactiveLayerIds\n          });\n\n          e.features = features;\n        }\n\n        cb(e);\n        delete e.features;\n      }\n    };\n\n    this._onCameraEvent = function (e) {\n      if (!_this._internalUpdate) {\n        // @ts-ignore\n        var cb = _this.props[cameraEvents[e.type]];\n\n        if (cb) {\n          cb(e);\n        }\n      }\n\n      if (e.type in _this._deferredEvents) {\n        _this._deferredEvents[e.type] = false;\n      }\n    };\n\n    this._MapClass = MapClass;\n    this.props = props;\n\n    this._initialize(container);\n  }\n\n  _createClass(Mapbox, [{\n    key: \"map\",\n    get: function get() {\n      return this._map;\n    }\n  }, {\n    key: \"transform\",\n    get: function get() {\n      return this._renderTransform;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      var oldProps = this.props;\n      this.props = props;\n\n      var settingsChanged = this._updateSettings(props, oldProps);\n\n      if (settingsChanged) {\n        this._createShadowTransform(this._map);\n      }\n\n      var sizeChanged = this._updateSize(props);\n\n      var viewStateChanged = this._updateViewState(props, true);\n\n      this._updateStyle(props, oldProps);\n\n      this._updateStyleComponents(props, oldProps);\n\n      this._updateHandlers(props, oldProps); // If 1) view state has changed to match props and\n      //    2) the props change is not triggered by map events,\n      // it's driven by an external state change. Redraw immediately\n\n\n      if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n        this.redraw();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value:\n    /* eslint-disable complexity,max-statements */\n    function _initialize(container) {\n      var _this2 = this;\n\n      var props = this.props;\n\n      var mapOptions = _objectSpread(_objectSpread(_objectSpread({}, props), props.initialViewState), {}, {\n        accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n        container: container,\n        style: normalizeStyle(props.mapStyle)\n      });\n\n      var viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n      Object.assign(mapOptions, {\n        center: [viewState.longitude || 0, viewState.latitude || 0],\n        zoom: viewState.zoom || 0,\n        pitch: viewState.pitch || 0,\n        bearing: viewState.bearing || 0\n      });\n\n      if (props.gl) {\n        // eslint-disable-next-line\n        var getContext = HTMLCanvasElement.prototype.getContext; // Hijack canvas.getContext to return our own WebGLContext\n        // This will be called inside the mapboxgl.Map constructor\n        // @ts-expect-error\n\n        HTMLCanvasElement.prototype.getContext = function () {\n          // Unhijack immediately\n          HTMLCanvasElement.prototype.getContext = getContext;\n          return props.gl;\n        };\n      }\n\n      var map = new this._MapClass(mapOptions); // Props that are not part of constructor options\n\n      if (viewState.padding) {\n        map.setPadding(viewState.padding);\n      }\n\n      if (props.cursor) {\n        map.getCanvas().style.cursor = props.cursor;\n      }\n\n      this._createShadowTransform(map); // Hack\n      // Insert code into map's render cycle\n\n\n      var renderMap = map._render;\n\n      map._render = function (arg) {\n        _this2._inRender = true;\n        renderMap.call(map, arg);\n        _this2._inRender = false;\n      };\n\n      var runRenderTaskQueue = map._renderTaskQueue.run;\n\n      map._renderTaskQueue.run = function (arg) {\n        runRenderTaskQueue.call(map._renderTaskQueue, arg);\n\n        _this2._onBeforeRepaint();\n      };\n\n      map.on('render', function () {\n        return _this2._onAfterRepaint();\n      }); // Insert code into map's event pipeline\n\n      var fireEvent = map.fire;\n      map.fire = this._fireEvent.bind(this, fireEvent); // add listeners\n\n      map.on('resize', function () {\n        _this2._renderTransform.resize(map.transform.width, map.transform.height);\n      });\n      map.on('styledata', function () {\n        return _this2._updateStyleComponents(_this2.props, {});\n      });\n      map.on('sourcedata', function () {\n        return _this2._updateStyleComponents(_this2.props, {});\n      });\n\n      for (var eventName in pointerEvents) {\n        map.on(eventName, this._onPointerEvent);\n      }\n\n      for (var _eventName in cameraEvents) {\n        map.on(_eventName, this._onCameraEvent);\n      }\n\n      for (var _eventName2 in otherEvents) {\n        map.on(_eventName2, this._onEvent);\n      }\n\n      this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n\n  }, {\n    key: \"recycle\",\n    value: function recycle() {\n      // Clean up unnecessary elements before storing for reuse.\n      var container = this.map.getContainer();\n      var children = container.querySelector('[mapboxgl-children]');\n      children === null || children === void 0 ? void 0 : children.remove();\n      Mapbox.savedMaps.push(this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._map.remove();\n    } // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      var map = this._map; // map._render will throw error if style does not exist\n      // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n      //   /src/ui/map.js#L1834\n\n      if (!this._inRender && map.style) {\n        // cancel the scheduled update\n        if (map._frame) {\n          map._frame.cancel();\n\n          map._frame = null;\n        } // the order is important - render() may schedule another update\n\n\n        map._render();\n      }\n    }\n  }, {\n    key: \"_createShadowTransform\",\n    value: function _createShadowTransform(map) {\n      var renderTransform = cloneTransform(map.transform);\n      map.painter.transform = renderTransform;\n      this._renderTransform = renderTransform;\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n\n  }, {\n    key: \"_updateSize\",\n    value: function _updateSize(nextProps) {\n      // Check if size is controlled\n      var viewState = nextProps.viewState;\n\n      if (viewState) {\n        var map = this._map;\n\n        if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n          map.resize();\n          return true;\n        }\n      }\n\n      return false;\n    } // Adapted from map.jumpTo\n\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateViewState\",\n    value: function _updateViewState(nextProps, triggerEvents) {\n      if (this._internalUpdate) {\n        return false;\n      }\n\n      var map = this._map;\n      var tr = this._renderTransform; // Take a snapshot of the transform before mutation\n\n      var zoom = tr.zoom,\n          pitch = tr.pitch,\n          bearing = tr.bearing;\n      var isMoving = map.isMoving();\n\n      if (isMoving) {\n        // All movement of the camera is done relative to the sea level\n        tr.cameraElevationReference = 'sea';\n      }\n\n      var changed = applyViewStateToTransform(tr, _objectSpread(_objectSpread({}, transformToViewState(map.transform)), nextProps));\n\n      if (isMoving) {\n        // Reset camera reference\n        tr.cameraElevationReference = 'ground';\n      }\n\n      if (changed && triggerEvents) {\n        var deferredEvents = this._deferredEvents; // Delay DOM control updates to the next render cycle\n\n        deferredEvents.move = true;\n        deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n        deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n        deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n      } // Avoid manipulating the real transform when interaction/animation is ongoing\n      // as it would interfere with Mapbox's handlers\n\n\n      if (!isMoving) {\n        applyViewStateToTransform(map.transform, nextProps);\n      }\n\n      return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateSettings\",\n    value: function _updateSettings(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      var _iterator = _createForOfIteratorHelper(settingNames),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var propName = _step.value;\n\n          if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n            changed = true;\n            map[\"set\".concat(propName[0].toUpperCase()).concat(propName.slice(1))](nextProps[propName]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n\n  }, {\n    key: \"_updateStyle\",\n    value: function _updateStyle(nextProps, currProps) {\n      if (nextProps.cursor !== currProps.cursor) {\n        this._map.getCanvas().style.cursor = nextProps.cursor;\n      }\n\n      if (nextProps.mapStyle !== currProps.mapStyle) {\n        var options = {\n          diff: nextProps.styleDiffing\n        };\n\n        if ('localIdeographFontFamily' in nextProps) {\n          options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n        }\n\n        this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n\n        return true;\n      }\n\n      return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateStyleComponents\",\n    value: function _updateStyleComponents(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      if (map.style.loaded()) {\n        if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n          changed = true;\n          map.setLight(nextProps.light);\n        }\n\n        if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n          changed = true;\n          map.setFog(nextProps.fog);\n        }\n\n        if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n          if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n            changed = true;\n            map.setTerrain(nextProps.terrain);\n          }\n        }\n      }\n\n      return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateHandlers\",\n    value: function _updateHandlers(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      var _iterator2 = _createForOfIteratorHelper(handlerNames),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var propName = _step2.value;\n          var newValue = nextProps[propName];\n\n          if (!deepEqual(newValue, currProps[propName])) {\n            changed = true;\n\n            if (newValue) {\n              map[propName].enable(newValue);\n            } else {\n              map[propName].disable();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"_updateHover\",\n    value: function _updateHover(e) {\n      var _a;\n\n      var props = this.props;\n      var shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n      if (shouldTrackHoveredFeatures) {\n        var eventType = e.type;\n        var wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        var features;\n\n        if (eventType === 'mousemove') {\n          try {\n            features = this._map.queryRenderedFeatures(e.point, {\n              layers: props.interactiveLayerIds\n            });\n          } catch (_b) {\n            features = [];\n          }\n        } else {\n          features = [];\n        }\n\n        var isHovering = features.length > 0;\n\n        if (!isHovering && wasHovering) {\n          e.type = 'mouseleave';\n\n          this._onPointerEvent(e);\n        }\n\n        this._hoveredFeatures = features;\n\n        if (isHovering && !wasHovering) {\n          e.type = 'mouseenter';\n\n          this._onPointerEvent(e);\n        }\n\n        e.type = eventType;\n      } else {\n        this._hoveredFeatures = null;\n      }\n    }\n  }, {\n    key: \"_fireEvent\",\n    value: function _fireEvent(baseFire, event, properties) {\n      var map = this._map;\n      var tr = map.transform;\n      var eventType = typeof event === 'string' ? event : event.type;\n\n      if (eventType === 'move') {\n        this._updateViewState(this.props, false);\n      }\n\n      if (eventType in cameraEvents) {\n        if (typeof event === 'object') {\n          event.viewState = transformToViewState(tr);\n        }\n\n        if (this._map.isMoving()) {\n          // Replace map.transform with ours during the callbacks\n          map.transform = this._renderTransform;\n          baseFire.call(map, event, properties);\n          map.transform = tr;\n          return map;\n        }\n      }\n\n      baseFire.call(map, event, properties);\n      return map;\n    } // All camera manipulations are complete, ready to repaint\n\n  }, {\n    key: \"_onBeforeRepaint\",\n    value: function _onBeforeRepaint() {\n      var _this3 = this;\n\n      var map = this._map; // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n\n      this._internalUpdate = true;\n\n      for (var eventType in this._deferredEvents) {\n        if (this._deferredEvents[eventType]) {\n          map.fire(eventType);\n        }\n      }\n\n      this._internalUpdate = false;\n      var tr = this._map.transform; // Make sure camera matches the current props\n\n      this._map.transform = this._renderTransform;\n\n      this._onAfterRepaint = function () {\n        // Restores camera state before render/load events are fired\n        _this3._map.transform = tr;\n      };\n    }\n  }], [{\n    key: \"reuse\",\n    value: function reuse(props, container) {\n      var that = Mapbox.savedMaps.pop();\n\n      if (!that) {\n        return null;\n      }\n\n      var map = that.map; // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n      // intoto the new container from the props.\n      // Step1: reparenting child nodes from old container to new container\n\n      var oldContainer = map.getContainer();\n      container.className = oldContainer.className;\n\n      while (oldContainer.childNodes.length > 0) {\n        container.appendChild(oldContainer.childNodes[0]);\n      } // Step2: replace the internal container with new container from the react component\n      // @ts-ignore\n\n\n      map._container = container; // Step 3: apply new props\n\n      that.setProps(_objectSpread(_objectSpread({}, props), {}, {\n        styleDiffing: false\n      }));\n      map.resize();\n      var initialViewState = props.initialViewState;\n\n      if (initialViewState) {\n        if (initialViewState.bounds) {\n          map.fitBounds(initialViewState.bounds, _objectSpread(_objectSpread({}, initialViewState.fitBoundsOptions), {}, {\n            duration: 0\n          }));\n        } else {\n          that._updateViewState(initialViewState, false);\n        }\n      } // Simulate load event\n\n\n      if (map.isStyleLoaded()) {\n        map.fire('load');\n      } else {\n        map.once('styledata', function () {\n          return map.fire('load');\n        });\n      }\n\n      return that;\n    }\n  }]);\n\n  return Mapbox;\n}();\n\nexport { Mapbox as default };\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\n\nfunction getAccessTokenFromEnv() {\n  var accessToken = null;\n  /* global location, process */\n\n  if (typeof location !== 'undefined') {\n    var match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  } // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n\n\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch (_a) {// ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch (_b) {// ignore\n  }\n\n  return accessToken;\n}","map":{"version":3,"sources":["../../../src/mapbox/mapbox.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nconst pointerEvents = {\n    mousedown: 'onMouseDown',\n    mouseup: 'onMouseUp',\n    mouseover: 'onMouseOver',\n    mousemove: 'onMouseMove',\n    click: 'onClick',\n    dblclick: 'onDblClick',\n    mouseenter: 'onMouseEnter',\n    mouseleave: 'onMouseLeave',\n    mouseout: 'onMouseOut',\n    contextmenu: 'onContextMenu',\n    touchstart: 'onTouchStart',\n    touchend: 'onTouchEnd',\n    touchmove: 'onTouchMove',\n    touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n    movestart: 'onMoveStart',\n    move: 'onMove',\n    moveend: 'onMoveEnd',\n    dragstart: 'onDragStart',\n    drag: 'onDrag',\n    dragend: 'onDragEnd',\n    zoomstart: 'onZoomStart',\n    zoom: 'onZoom',\n    zoomend: 'onZoomEnd',\n    rotatestart: 'onRotateStart',\n    rotate: 'onRotate',\n    rotateend: 'onRotateEnd',\n    pitchstart: 'onPitchStart',\n    pitch: 'onPitch',\n    pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n    wheel: 'onWheel',\n    boxzoomstart: 'onBoxZoomStart',\n    boxzoomend: 'onBoxZoomEnd',\n    boxzoomcancel: 'onBoxZoomCancel',\n    resize: 'onResize',\n    load: 'onLoad',\n    render: 'onRender',\n    idle: 'onIdle',\n    remove: 'onRemove',\n    data: 'onData',\n    styledata: 'onStyleData',\n    sourcedata: 'onSourceData',\n    error: 'onError'\n};\nconst settingNames = [\n    'minZoom',\n    'maxZoom',\n    'minPitch',\n    'maxPitch',\n    'maxBounds',\n    'projection',\n    'renderWorldCopies'\n];\nconst handlerNames = [\n    'scrollZoom',\n    'boxZoom',\n    'dragRotate',\n    'dragPan',\n    'keyboard',\n    'doubleClickZoom',\n    'touchZoomRotate',\n    'touchPitch'\n];\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox {\n    constructor(MapClass, props, container) {\n        // mapboxgl.Map instance. Not using type here because we are accessing\n        // private members and methods\n        this._map = null;\n        // Internal states\n        this._internalUpdate = false;\n        this._inRender = false;\n        this._hoveredFeatures = null;\n        this._deferredEvents = {\n            move: false,\n            zoom: false,\n            pitch: false,\n            rotate: false\n        };\n        this._onEvent = (e) => {\n            // @ts-ignore\n            const cb = this.props[otherEvents[e.type]];\n            if (cb) {\n                cb(e);\n            }\n        };\n        this._onPointerEvent = (e) => {\n            if (e.type === 'mousemove' || e.type === 'mouseout') {\n                this._updateHover(e);\n            }\n            // @ts-ignore\n            const cb = this.props[pointerEvents[e.type]];\n            if (cb) {\n                if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n                    const features = this._hoveredFeatures ||\n                        this._map.queryRenderedFeatures(e.point, {\n                            layers: this.props.interactiveLayerIds\n                        });\n                    e.features = features;\n                }\n                cb(e);\n                delete e.features;\n            }\n        };\n        this._onCameraEvent = (e) => {\n            if (!this._internalUpdate) {\n                // @ts-ignore\n                const cb = this.props[cameraEvents[e.type]];\n                if (cb) {\n                    cb(e);\n                }\n            }\n            if (e.type in this._deferredEvents) {\n                this._deferredEvents[e.type] = false;\n            }\n        };\n        this._MapClass = MapClass;\n        this.props = props;\n        this._initialize(container);\n    }\n    get map() {\n        return this._map;\n    }\n    get transform() {\n        return this._renderTransform;\n    }\n    setProps(props) {\n        const oldProps = this.props;\n        this.props = props;\n        const settingsChanged = this._updateSettings(props, oldProps);\n        if (settingsChanged) {\n            this._createShadowTransform(this._map);\n        }\n        const sizeChanged = this._updateSize(props);\n        const viewStateChanged = this._updateViewState(props, true);\n        this._updateStyle(props, oldProps);\n        this._updateStyleComponents(props, oldProps);\n        this._updateHandlers(props, oldProps);\n        // If 1) view state has changed to match props and\n        //    2) the props change is not triggered by map events,\n        // it's driven by an external state change. Redraw immediately\n        if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n            this.redraw();\n        }\n    }\n    static reuse(props, container) {\n        const that = Mapbox.savedMaps.pop();\n        if (!that) {\n            return null;\n        }\n        const map = that.map;\n        // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n        // intoto the new container from the props.\n        // Step1: reparenting child nodes from old container to new container\n        const oldContainer = map.getContainer();\n        container.className = oldContainer.className;\n        while (oldContainer.childNodes.length > 0) {\n            container.appendChild(oldContainer.childNodes[0]);\n        }\n        // Step2: replace the internal container with new container from the react component\n        // @ts-ignore\n        map._container = container;\n        // Step 3: apply new props\n        that.setProps({ ...props, styleDiffing: false });\n        map.resize();\n        const { initialViewState } = props;\n        if (initialViewState) {\n            if (initialViewState.bounds) {\n                map.fitBounds(initialViewState.bounds, { ...initialViewState.fitBoundsOptions, duration: 0 });\n            }\n            else {\n                that._updateViewState(initialViewState, false);\n            }\n        }\n        // Simulate load event\n        if (map.isStyleLoaded()) {\n            map.fire('load');\n        }\n        else {\n            map.once('styledata', () => map.fire('load'));\n        }\n        return that;\n    }\n    /* eslint-disable complexity,max-statements */\n    _initialize(container) {\n        const { props } = this;\n        const mapOptions = {\n            ...props,\n            ...props.initialViewState,\n            accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n            container,\n            style: normalizeStyle(props.mapStyle)\n        };\n        const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n        Object.assign(mapOptions, {\n            center: [viewState.longitude || 0, viewState.latitude || 0],\n            zoom: viewState.zoom || 0,\n            pitch: viewState.pitch || 0,\n            bearing: viewState.bearing || 0\n        });\n        if (props.gl) {\n            // eslint-disable-next-line\n            const getContext = HTMLCanvasElement.prototype.getContext;\n            // Hijack canvas.getContext to return our own WebGLContext\n            // This will be called inside the mapboxgl.Map constructor\n            // @ts-expect-error\n            HTMLCanvasElement.prototype.getContext = () => {\n                // Unhijack immediately\n                HTMLCanvasElement.prototype.getContext = getContext;\n                return props.gl;\n            };\n        }\n        const map = new this._MapClass(mapOptions);\n        // Props that are not part of constructor options\n        if (viewState.padding) {\n            map.setPadding(viewState.padding);\n        }\n        if (props.cursor) {\n            map.getCanvas().style.cursor = props.cursor;\n        }\n        this._createShadowTransform(map);\n        // Hack\n        // Insert code into map's render cycle\n        const renderMap = map._render;\n        map._render = (arg) => {\n            this._inRender = true;\n            renderMap.call(map, arg);\n            this._inRender = false;\n        };\n        const runRenderTaskQueue = map._renderTaskQueue.run;\n        map._renderTaskQueue.run = (arg) => {\n            runRenderTaskQueue.call(map._renderTaskQueue, arg);\n            this._onBeforeRepaint();\n        };\n        map.on('render', () => this._onAfterRepaint());\n        // Insert code into map's event pipeline\n        const fireEvent = map.fire;\n        map.fire = this._fireEvent.bind(this, fireEvent);\n        // add listeners\n        map.on('resize', () => {\n            this._renderTransform.resize(map.transform.width, map.transform.height);\n        });\n        map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n        map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n        for (const eventName in pointerEvents) {\n            map.on(eventName, this._onPointerEvent);\n        }\n        for (const eventName in cameraEvents) {\n            map.on(eventName, this._onCameraEvent);\n        }\n        for (const eventName in otherEvents) {\n            map.on(eventName, this._onEvent);\n        }\n        this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n    recycle() {\n        // Clean up unnecessary elements before storing for reuse.\n        const container = this.map.getContainer();\n        const children = container.querySelector('[mapboxgl-children]');\n        children === null || children === void 0 ? void 0 : children.remove();\n        Mapbox.savedMaps.push(this);\n    }\n    destroy() {\n        this._map.remove();\n    }\n    // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n    redraw() {\n        const map = this._map;\n        // map._render will throw error if style does not exist\n        // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n        //   /src/ui/map.js#L1834\n        if (!this._inRender && map.style) {\n            // cancel the scheduled update\n            if (map._frame) {\n                map._frame.cancel();\n                map._frame = null;\n            }\n            // the order is important - render() may schedule another update\n            map._render();\n        }\n    }\n    _createShadowTransform(map) {\n        const renderTransform = cloneTransform(map.transform);\n        map.painter.transform = renderTransform;\n        this._renderTransform = renderTransform;\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n    _updateSize(nextProps) {\n        // Check if size is controlled\n        const { viewState } = nextProps;\n        if (viewState) {\n            const map = this._map;\n            if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n                map.resize();\n                return true;\n            }\n        }\n        return false;\n    }\n    // Adapted from map.jumpTo\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n    _updateViewState(nextProps, triggerEvents) {\n        if (this._internalUpdate) {\n            return false;\n        }\n        const map = this._map;\n        const tr = this._renderTransform;\n        // Take a snapshot of the transform before mutation\n        const { zoom, pitch, bearing } = tr;\n        const isMoving = map.isMoving();\n        if (isMoving) {\n            // All movement of the camera is done relative to the sea level\n            tr.cameraElevationReference = 'sea';\n        }\n        const changed = applyViewStateToTransform(tr, {\n            ...transformToViewState(map.transform),\n            ...nextProps\n        });\n        if (isMoving) {\n            // Reset camera reference\n            tr.cameraElevationReference = 'ground';\n        }\n        if (changed && triggerEvents) {\n            const deferredEvents = this._deferredEvents;\n            // Delay DOM control updates to the next render cycle\n            deferredEvents.move = true;\n            deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n            deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n            deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n        }\n        // Avoid manipulating the real transform when interaction/animation is ongoing\n        // as it would interfere with Mapbox's handlers\n        if (!isMoving) {\n            applyViewStateToTransform(map.transform, nextProps);\n        }\n        return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateSettings(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of settingNames) {\n            if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n                changed = true;\n                map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n            }\n        }\n        return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n    _updateStyle(nextProps, currProps) {\n        if (nextProps.cursor !== currProps.cursor) {\n            this._map.getCanvas().style.cursor = nextProps.cursor;\n        }\n        if (nextProps.mapStyle !== currProps.mapStyle) {\n            const options = {\n                diff: nextProps.styleDiffing\n            };\n            if ('localIdeographFontFamily' in nextProps) {\n                options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n            }\n            this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n            return true;\n        }\n        return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateStyleComponents(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        if (map.style.loaded()) {\n            if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n                changed = true;\n                map.setLight(nextProps.light);\n            }\n            if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n                changed = true;\n                map.setFog(nextProps.fog);\n            }\n            if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n                if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n                    changed = true;\n                    map.setTerrain(nextProps.terrain);\n                }\n            }\n        }\n        return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateHandlers(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of handlerNames) {\n            const newValue = nextProps[propName];\n            if (!deepEqual(newValue, currProps[propName])) {\n                changed = true;\n                if (newValue) {\n                    map[propName].enable(newValue);\n                }\n                else {\n                    map[propName].disable();\n                }\n            }\n        }\n        return changed;\n    }\n    _updateHover(e) {\n        var _a;\n        const { props } = this;\n        const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n        if (shouldTrackHoveredFeatures) {\n            const eventType = e.type;\n            const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n            let features;\n            if (eventType === 'mousemove') {\n                try {\n                    features = this._map.queryRenderedFeatures(e.point, {\n                        layers: props.interactiveLayerIds\n                    });\n                }\n                catch (_b) {\n                    features = [];\n                }\n            }\n            else {\n                features = [];\n            }\n            const isHovering = features.length > 0;\n            if (!isHovering && wasHovering) {\n                e.type = 'mouseleave';\n                this._onPointerEvent(e);\n            }\n            this._hoveredFeatures = features;\n            if (isHovering && !wasHovering) {\n                e.type = 'mouseenter';\n                this._onPointerEvent(e);\n            }\n            e.type = eventType;\n        }\n        else {\n            this._hoveredFeatures = null;\n        }\n    }\n    _fireEvent(baseFire, event, properties) {\n        const map = this._map;\n        const tr = map.transform;\n        const eventType = typeof event === 'string' ? event : event.type;\n        if (eventType === 'move') {\n            this._updateViewState(this.props, false);\n        }\n        if (eventType in cameraEvents) {\n            if (typeof event === 'object') {\n                event.viewState = transformToViewState(tr);\n            }\n            if (this._map.isMoving()) {\n                // Replace map.transform with ours during the callbacks\n                map.transform = this._renderTransform;\n                baseFire.call(map, event, properties);\n                map.transform = tr;\n                return map;\n            }\n        }\n        baseFire.call(map, event, properties);\n        return map;\n    }\n    // All camera manipulations are complete, ready to repaint\n    _onBeforeRepaint() {\n        const map = this._map;\n        // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n        this._internalUpdate = true;\n        for (const eventType in this._deferredEvents) {\n            if (this._deferredEvents[eventType]) {\n                map.fire(eventType);\n            }\n        }\n        this._internalUpdate = false;\n        const tr = this._map.transform;\n        // Make sure camera matches the current props\n        this._map.transform = this._renderTransform;\n        this._onAfterRepaint = () => {\n            // Restores camera state before render/load events are fired\n            this._map.transform = tr;\n        };\n    }\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv() {\n    let accessToken = null;\n    /* global location, process */\n    if (typeof location !== 'undefined') {\n        const match = /access_token=([^&\\/]*)/.exec(location.search);\n        accessToken = match && match[1];\n    }\n    // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n    try {\n        accessToken = accessToken || process.env.MapboxAccessToken;\n    }\n    catch (_a) {\n        // ignore\n    }\n    try {\n        accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n    }\n    catch (_b) {\n        // ignore\n    }\n    return accessToken;\n}\n//# sourceMappingURL=mapbox.js.map"]},"metadata":{},"sourceType":"module"}